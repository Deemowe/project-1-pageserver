__author__ = "Deem Alowairdhi"
__email__ = "411214706@qu.edu.sa"

"""
  A trivial web server in Python.

  Based largely on https://docs.python.org/3.9/howto/sockets.html
  This trivial implementation is not robust: We have omitted decent
  error handling and many other things to keep the illustration as simple
  as possible.
"""
 

"""
Python modules and libraries are imported.

* a module is a file containing Python code.
The code within a module can define functions, classes, and 
variables, which can be reused in other Python scripts.
 Modules are used to organize code into separate files, 
 making it more manageable and promoting code reusability.
"""
import config    # Configure from .ini files and command line
import logging   # Better than print statements
import socket    # Basic TCP/IP communication on the internet
import _thread   # Response computation runs concurrently with main program
from typing import Callable
import os

# Starter version only serves cat pictures.
CAT = """
     ^ ^
   =(   )=
"""

# HTTP response codes, as the strings we will actually send.
# See:  https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
# or    https://www.rfc-editor.org/rfc/rfc9110.html
STATUS_OK = "HTTP/1.0 200 OK\n\n"
STATUS_FORBIDDEN = "HTTP/1.0 403 Forbidden\n\n"
STATUS_NOT_FOUND = "HTTP/1.0 404 Not Found\n\n"
STATUS_NOT_IMPLEMENTED = "HTTP/1.0 401 Not Implemented\n\n"

"""
Not Implemented
The server either does not recognize the request method, 
or it lacks the ability to fulfil the request.
 Usually this implies future availability 
 (e.g., a new feature of a web-service API).
"""


#------------ log part


""" 
A logger is a tool for recording messages
 (such as informational messages, warnings, and errors) generated by a program. """

""" 
This loop goes through all the existing log handlers 
(log output destinations) and removes them.
 It ensures that there are no pre-existing log handlers attached to the root logger.
   This step is useful to prevent duplicate log messages from being displayed.
"""

"""
In Python's logging module, handlers are objects responsible for processing log records. 
They define where log messages should be sent or stored, such as writing them to a file,
displaying them on the console, sending them over the network, or performing custom actions.
Handlers play a crucial role in controlling the destination of log messages generated by your program.
"""
# set up logger
for handler in logging.root.handlers[:]:  # make sure all handlers are removed
    logging.root.removeHandler(handler)




"""
This line sets the logging level to DEBUG. 
The logging level determines the severity of messages that will be logged.
 In this case, it's set to the lowest level, DEBUG, which means that all messages, 
including informational and debugging messages, will be logged.
"""
logging_level = logging.DEBUG 



"""
 It specifies how each log message should be formatted when it's written to the log output. 
 The format includes placeholders like %(asctime)s (timestamp), %(levelname)s (log level),
%(name)s (logger name), %(funcName)s (name of the function where the log message is generated), 
%(lineno)d (line number), and %(message)s (the log message itself).
"""
logging_format = logging.Formatter('%(asctime)s: %(levelname)s [%(name)s:%(funcName)s:%(lineno)d] - %(message)s')



logging.root.setLevel(logging_level) # DEBUG level

"""
This line creates a log handler named h of type StreamHandler.
A StreamHandler is a handler that writes log messages to a stream, 
which, in this case, is the standard output (console).
"""
h = logging.StreamHandler()
h.setFormatter(logging_format)



"""
This line adds the log handler h to the root logger.
 It means that from this point on, when you log messages using logging functions, 
 those messages will be directed to the console with the specified format.
"""
logging.root.addHandler(h)



"""
a logger object named log is created using logging.getLogger(__name__). 
This logger is associated with the name of the current module (the module in which this code is written). 
You can use this log object to record log messages specific to this module.
It allows you to control the logging behavior for this module independently.
"""
log = logging.getLogger(__name__)



#------------- end og log part




def listen(port_num: int):
    """
    Create and listen to a server socket.
    Args:
       port_num: Integer in range 1024-65535; temporary use ports
           should be in range 49152-65535.
    Returns:
       A server socket, unless connection fails (e.g., because
       the port is already in use).
    """


    """
    initializes a socket object server_socket configured for IPv4-based TCP communication.
    This socket will be used to create a server that can listen for incoming connections
    from clients and communicate with them using the TCP protocol.
    """
    # Internet, streaming socket
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


    """
    This line binds the server_socket to a specific port number (port_num). 
    Binding means associating the socket with a particular network port on the machine 
    where this code is running. The ('', port_num) argument pair means that the server socket 
    will listen on all available network interfaces (the empty string '') 
    and on the specified port number.
    """
    # Bind to port and make accessible from anywhere that has our IP address
    server_socket.bind(('', port_num))


    """
    This line configures the server socket to start listening for incoming connections. 
    The number 1 passed to listen() indicates that the socket can accept one incoming connection 
    at a time. In a real server, this number might be higher to handle multiple connections simultaneously.
    """
    server_socket.listen(1)    # A real server would have multiple listeners


    """
    This means that when you call the listen function, 
    it will give you a configured server socket that you can use to 
    accept incoming connections from clients.
    """
    return server_socket







def serve(sock: socket, func: Callable):
    """
    Respond to connections on sock.
    Args:
       sock:  A server socket, already listening on some port.
       func:  a function that takes a client socket and does something with it
    Returns: nothing
    Effects:
        For each connection, func is called on a client socket connected
        to the connected client, running concurrently in its own thread.

    Purpose:continuously accept client connections on the sock server socket 
    and start a new thread to handle each connection.

    """


    """
    This line starts an infinite loop. The code within this loop will keep running indefinitely 
    until an external action (like forcefully terminating the program) interrupts it.
    """
    while True:
        log.info(f"Attempting to accept a connection on {sock}")


        """
        This line waits for a client to connect to the server socket sock. 
        When a client connects, the accept method returns two values:
        
        1- client_socket: This is a new socket object that represents the connection to the connected client. 
        You can use this socket to send and receive data with the client.


        2- address: This is a tuple containing the IP address and port number of the client that connected to the server.
        """
        (client_socket, address) = sock.accept()

        """
        This line starts a new thread of execution. In Python, 
        a thread is a separate flow of control within a program.

        The start_new_thread function is used to create a new thread and execute 
        the specified function (func) concurrently in its own thread.


        """
        _thread.start_new_thread(func, (client_socket,))







# # This function is responsible for handling incoming requests from clients over a socket
# def respond(sock: socket):
#     """
#     This server responds only to GET requests (not PUT, POST, or UPDATE).
#     Any valid GET request is answered with an ascii graphic of a cat!
#     """

#     """
#     This line receives data from the client socket
#     It reads up to 1024 bytes of data from the client socket. 
#     This is where the server is expecting to receive the client's HTTP request.
#     """
#     request = sock.recv(1024)  # We accept only short requests


#     #This line converts the received data into a string
#     request = str(request, encoding='utf-8', errors='strict')
#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")



#     """
#     This line converts the received data into a string 
#     By default, it splits on whitespace.

#     This is done to analyze the request and determine if it's a valid HTTP GET request.
#     """
#     parts = request.split()


#     if len(parts) > 1 and parts[0] == "GET":
#         transmit(STATUS_OK, sock)
#         transmit(CAT, sock)
#     else:
#         log.info(f"Unhandled request: {request}")
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)

#     """
#     his line gracefully shuts down the socket in both directions (reading and writing). 
#     It's a way to signal that the server has finished communicating with the client
#     """
#     sock.shutdown(socket.SHUT_RDWR)

#     # This line closes the socket, releasing any resources associated with it.
#     sock.close()
#     # return




# def respond(sock: socket):
#     """
#     This server responds only to GET requests (not PUT, POST, or UPDATE).
#     Any valid GET request is answered with an ascii graphic of a cat!
#     """
#     request = sock.recv(1024)  # We accept only short requests
#     request = str(request, encoding='utf-8', errors='strict')
#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")

#     parts = request.split()
#     if len(parts) > 1 and parts[0] == "GET":
#         transmit(STATUS_OK, sock)
#         transmit(CAT, sock)
#     else:
#         log.info(f"Unhandled request: {request}")
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)

#     sock.shutdown(socket.SHUT_RDWR)
#     sock.close()
#     # return




# def respond(sock: socket):
#     request = sock.recv(1024)  # We accept only short requests
#     request = str(request, encoding='utf-8', errors='strict')
    
#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")
    
#     parts = request.split()
#     if len(parts) > 1 and parts[0] == "GET":
#         path = parts[1]
        
#         if path.startswith(("/", "~", "..")):
#             transmit(STATUS_FORBIDDEN, sock)
#             return
        
#         # Get DOCROOT from config
#         options = get_options()
#         doc_root = options.DOCROOT
        

#         file_path = os.path.join(doc_root, path[1:])
        
#         if os.path.exists(file_path) and (file_path.endswith('.html') or file_path.endswith('.css')):
#             with open(file_path, 'r') as f:
#                 content = f.read()
#                 transmit(STATUS_OK, sock)
#                 transmit(content, sock)
#         else:
#             transmit(STATUS_NOT_FOUND, sock)
#     else:
#         log.info(f"Unhandled request: {request}")
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)
    
#     sock.shutdown(socket.SHUT_RDWR)
#     sock.close()



# def respond(sock: socket):
#     request = sock.recv(1024)
#     request = str(request, encoding='utf-8', errors='strict')
#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")

#     parts = request.split()
#     if len(parts) > 1 and parts[0] == "GET":
#         url = parts[1]
        
#         # Getting the DOCROOT from the configuration
#         options = config.configuration()
#         doc_root = options.DOCROOT
        
#         if url.startswith(("/", "//", "~")):
#             transmit(STATUS_FORBIDDEN, sock)
#             transmit("403 Forbidden", sock)
#         else:
#             if url.endswith((".html", ".css")):
#                 file_path = os.path.join(doc_root, url[1:])
                
#                 if os.path.isfile(file_path):
#                     with open(file_path, 'r') as f:
#                         content = f.read()
#                         transmit(STATUS_OK, sock)
#                         transmit(content, sock)
#                 else:
#                     transmit(STATUS_NOT_FOUND, sock)
#                     transmit("404 Not Found", sock)
#             else:
#                 transmit(STATUS_NOT_IMPLEMENTED, sock)
#                 transmit(f"\nI don't handle this request: {request}\n", sock)
#     else:
#         log.info(f"Unhandled request: {request}")
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)

#     sock.shutdown(socket.SHUT_RDWR)
#     sock.close()


def respond(sock: socket):
    """
    Responds to GET requests with appropriate files and HTTP status codes.
    """
    request = sock.recv(1024)  # We accept only short requests
    request = str(request, encoding='utf-8', errors='strict')
    log.info("--- Received request ----")
    log.info(f"Request was {request}\n***\n")

    parts = request.split()
    if len(parts) > 1 and parts[0] == "GET":
        # Extract the file path from the request
        file_path = parts[1]

        # Check if the file path starts with forbidden symbols
        if any(forbidden in file_path for forbidden in ("~", "//", "..")):
            transmit(STATUS_FORBIDDEN, sock)
            log.info(f"403 Forbidden: {request}")
        else:
            # Get the absolute file path
            options = get_options()
            doc_root = options.DOCROOT
            absolute_file_path = os.path.join(doc_root, file_path[1:])

            # Check if the file exists and serve it
            if os.path.isfile(absolute_file_path):
                # Get the file extension
                _, ext = os.path.splitext(absolute_file_path)
                if ext in [".html", ".css"]:
                    with open(absolute_file_path, 'r') as f:
                        content = f.read()
                    transmit(STATUS_OK, sock)
                    transmit(content, sock)
                    # transmit(CAT, sock)
                else:
                    transmit(STATUS_NOT_FOUND, sock)
                    log.info(f"404 Not Found: {request}")

            else:
                transmit(STATUS_NOT_FOUND, sock)
                log.info(f"404 Not Found: {request}")
    else:
        log.info(f"Unhandled request: {request}")
        transmit(STATUS_NOT_IMPLEMENTED, sock)
        transmit(f"\nI don't handle this request: {request}\n", sock)

    sock.shutdown(socket.SHUT_RDWR)
    sock.close()



# def respond(sock: socket):
#     request = sock.recv(1024)
#     request = str(request, encoding='utf-8', errors='strict')

#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")

#     parts = request.split()
#     if len(parts) > 1 and parts[0] == "GET":
#         # Get the file path from the URL (ignoring query parameters)
#         filepath = parts[1].split('?')[0]

#         # Check for forbidden symbols
#         if filepath.startswith(("~", "//", "..")):
#             transmit(STATUS_FORBIDDEN, sock)
#         else:
#             # Check for file existence and type (.html or .css)
#             file_name = os.path.basename(filepath)
#             if file_name.endswith(('.html', '.css')):
#                 file_path = os.path.join('DOCROOT', file_name)
#                 if os.path.isfile(file_path):
#                     with open(file_path, 'r') as file:
#                         content = file.read()
#                     transmit(STATUS_OK, sock)
#                     transmit(content, sock)
#                 else:
#                     transmit(STATUS_NOT_FOUND, sock)
#             else:
#                 transmit(STATUS_NOT_IMPLEMENTED, sock)
#     else:
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)

#     sock.shutdown(socket.SHUT_RDWR)
#     sock.close()



# import os
# import socket

# def respond(sock: socket):
#     """
#     Responds to GET requests with appropriate files and HTTP status codes.
#     """
#     request = sock.recv(1024)  # We accept only short requests
#     request = str(request, encoding='utf-8', errors='strict')
#     log.info("--- Received request ----")
#     log.info(f"Request was {request}\n***\n")

#     parts = request.split()
#     if len(parts) > 1 and parts[0] == "GET":
#         # Extract the file path from the request
#         file_path = parts[1]

#         # Check if the file path starts with forbidden symbols or contains forbidden sequences
#         if file_path.startswith("~"):
#             transmit(STATUS_FORBIDDEN, sock)
#         else:
#             normalized_path = os.path.normpath(file_path)
#             if ".." in normalized_path or "//" in normalized_path:
#                 transmit(STATUS_FORBIDDEN, sock)
#             else:
#                 # Get the absolute file path
#                 options = get_options()
#                 doc_root = options.DOCROOT
#                 absolute_file_path = os.path.join(doc_root, normalized_path.lstrip('/'))

#                 # Check if the file exists and serve it
#                 if os.path.isfile(absolute_file_path):
#                     # Get the file extension
#                     _, ext = os.path.splitext(absolute_file_path)
#                     if ext in [".html", ".css"]:
#                         with open(absolute_file_path, 'r') as f:
#                             content = f.read()
#                         transmit(STATUS_OK, sock)
#                         transmit(content, sock)
#                     else:
#                         transmit(STATUS_NOT_FOUND, sock)
#                 else:
#                     transmit(STATUS_NOT_FOUND, sock)
#     else:
#         log.info(f"Unhandled request: {request}")
#         transmit(STATUS_NOT_IMPLEMENTED, sock)
#         transmit(f"\nI don't handle this request: {request}\n", sock)

#     sock.shutdown(socket.SHUT_RDWR)
#     sock.close()


# This function is responsible for sending a message (a string) over a network socket.
def transmit(msg: str, sock: socket):
    """It might take several sends to get the whole message out"""

    # will be used to keep track of how many bytes of the message have been sent so far.
    sent = 0

    # It loops until the entire message has been sent.
    while sent < len(msg):
        buff = bytes(msg[sent:], encoding="utf-8")
        sent += sock.send(buff)


# Run from command line, responsible for getting options from the command line or configuration file
def get_options():
    """
    Options from command line or configuration file.
    Returns namespace object with option value for port
    """

    # Defaults from configuration files; on conflict, the last value read has precedence
    # We want: PORT and DOCROOT
    options = config.configuration()

    if options.PORT <= 1000:
        log.warning(f"Port {options.port} selected. Ports 0..1000 are reserved by the operating system!")
    return options


def main():
    options = get_options()
    port = options.PORT
    if options.DEBUG:
        log.setLevel(logging.DEBUG)

    sock = listen(port)
    log.info(f"Listening on port {port}")
    log.info(f"Socket is {sock}")
    serve(sock, respond)


if __name__ == "__main__":
    main()
